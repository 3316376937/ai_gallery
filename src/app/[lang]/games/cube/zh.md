
## 在线魔方可视化设计

魔方为官方配色版本：分别为白色、红色、橙色、黄色、绿色、蓝色，其中白黄相对、红橙相对、蓝绿相对，且蓝、橙、黄三色以顺时钟排列。






现在实现扭魔方的动画，在魔方表面某个方格，可以左右或者上下拖动，这样实现旋转那个方格所在面。
这里可以分步实现，先实现定位方格和旋转方向，然后再实现旋转的逻辑。


法线（Normal）是一个垂直于面的向量，用来表示这个面朝向哪个方向。在魔方中：
前面（红色）的法线是 (0, 0, 1)，表示这个面朝向 Z 轴正方向
后面（橙色）的法线是 (0, 0, -1)，表示这个面朝向 Z 轴负方向
上面（白色）的法线是 (0, 1, 0)，表示这个面朝向 Y 轴正方向
下面（黄色）的法线是 (0, -1, 0)，表示这个面朝向 Y 轴负方向
右面（蓝色）的法线是 (1, 0, 0)，表示这个面朝向 X 轴正方向
左面（绿色）的法线是 (-1, 0, 0)，表示这个面朝向 X 轴负方向

法线是相对于物体本身的固定朝向，不会随着相机视角的改变而改变。
比如魔方的前面（红色面）。它的法线永远是 (0, 0, 1)，表示这个面永远朝向 Z 轴正方向
即使我们旋转相机到上面看，或者从侧面看，这个面的法线方向相对于魔方本身是不变的。


垂直拖动时：
操作 X 轴的列（左中右列）的面：
前面（红色，z = 1）
后面（橙色，z = -1）：方向相反
上面（白色，y = 1）
下面（黄色，y = -1）
操作 Z 轴的列（前中后列）的面：
右面（蓝色，x = 1）
左面（绿色，x = -1）：方向相反

1. 对于前视图（front）：
z = 1 的位置确实都属于红色面
即使其他颜色转到这个位置，它仍然是红色面的一部分
但对于上视图（up）：
当我们从上面看时，y = 1 的判断是不对的
因为此时我们看到的是相对于相机的"上面"，而不是魔方的原始上面
我们需要考虑相机的视角和魔方的实际旋转状态。


在 Three.js 中，相机视角是通过相机的位置（position）和朝向（lookAt）来定义的。
当我们使用 OrbitControls（轨道控制器）时，相机会围绕目标点旋转，但是世界坐标系是不变的：
X 轴：左右方向
Y 轴：上下方向
Z 轴：前后方向
所以当我们旋转视角时：
1. 相机的位置会改变
但是魔方的坐标系和旋转轴保持不变
这就导致了从不同角度看时，同样的拖动会产生不同的效果


关键是要从相机视角来判断"层"。无论从哪个角度看，我们都希望：
左右滑动时，旋转当前视觉上的"水平层"
2. 这个"水平层"是相对于相机视角的，而不是固定的世界坐标



这里决定移动方向算法不对，如图红色面中间那行，我向右滑，现在显示向下。

对于每次滑动，先判断经过的格子是否在同一个行，或者同一个列上，如果不是滑动无效。如果是的滑，经过多个格子，则根据经过格子的朝向来决定滑动方向。如果只是在一个格子上，则看哪个方向向量最大，则按那个方向。

这里方向只能有上下左右四种。



我鼠标点击某个方格，然后开始移动。

这时候有四个方向，分别是上下左右，你选择我移动最大向量作为移动方向。
决定方向后，就根据当前方格的相机视觉位置，来决定要旋转的面。接着根据不同的方向来旋转面。


这里判断方向不对。

这里滑动方向要以电脑屏幕的鼠标移动方向为准，不用管相机或者世界坐标这样



获取相机在世界坐标系中的位置
计算相机相对于魔方中心的方位角
根据相机角度将世界坐标转换为相对坐标（近/中/远）
根据相对位置决定旋转哪个竖面
这样，无论魔方旋转到什么位置：
靠近相机的一列始终是 'R'（近面）
中间的一列始终是 'C'（中列）
远离相机的一列始终是 'L'（远面）
这样就能保证操作的一致性，不管魔方转到什么角度，从上面向右滑动时：
近面的块会触发近面的列向上旋转
中间的块会触发中列向上旋转
远面的块会触发远面的列向上旋转
