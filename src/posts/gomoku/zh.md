
## 实现

继续拆分。先单独实现一个连续活三的检测。对于一个落点，检查前、后两个点是否是是同一方，之后检测两段是否是空白的。比如落点 X，连续活三有两种情况：

```
_00X_
_X00_
```

在满足1 种的情况下就是活三。

用模式匹配的方法来，检测冲四：
1. 连续的四子加一个空位（WBBBBX），这种另一端是对方或者边界；
2. 中间有一个空位的四子（BBBXB），这里是对称，左右都可以；
3. 两端各有两个子的冲四（BBXBB），棋子要在中间。

扫描 row,col 周边的点，保证有 3 个同样的 player 以及一个空格。
如果空格在最边的一端位置，还要保证另一端有阻挡（对手棋子或者边界）
下面 1 代表边界或者对手棋子，_ 代表空格，X代表检测冲四的棋子位置。0 代表先手棋子。

比如下面都是冲四：
10_X00 
0_X000

重修修改这里，不单独判断冲四。直接增加一个计算活四或者冲四连接的方法。

对于某个先手落子，算出再下一个棋子会五连的所有情况。
对于每一种五连，记录用到的当前 4 个棋子的位置，以及需要再下棋子的位置。

然后按照用到的 4连棋子的位置进行聚合，计算出每种情况下，需要下的棋子的位置，如果对于某四个棋子，只有一个位置可以行成五连，就是冲四。有两个位置可以形成五连，就是活四。

函数返回两部分，一个是冲四的棋子位置，一个是活四的棋子位置
